/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: skwon2 <skwon2@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/11/02 14:42:15 by skwon2            #+#    #+#             */
/*   Updated: 2023/11/02 15:51:26 by skwon2           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <string.h>

//하나의 메모리당 1바이트를 가진다
//str[]생각하는 배열과는 조금 다르고  

void *  ft_memset(void *b, int c, size_t len)
{
    int i;

    i = -1;
    while(++i < len)
    {
      *(unsigned char)(b + i)
    }

}

//void = 반환값이 없는 함수.

// b[i] = c;
// b를 배열처럼 직접 사용하려고 하면 컴파일 오류가 발생합니다. 이는 b가 void * 형식의 포인터로 선언되었기 때문
//void * 포인터는 일반적으로 메모리 주소를 가리키고 있으며 데이터 타입 정보가 없습니다. 이것은 임의의 데이터 타입을 가리킬 수 있지만,
//  void * 포인터를 사용하여 해당 메모리를 직접 엑세스하려고 하면 컴파일러가 경고 또는 오류를 발생시킵니다.
int main(void)
{
    int myArray[10];
    printf("sizeof(): %lu\n", sizeof(myArray));
    memset(myArray, 0, sizeof(myArray));
    // myArray[i] 값이 0으로 설정된다면 => 해당 요소가 초기화된 것, 즉 0또는 null로 표기된다.
    // sizeof 연산자는 컴파일 타임에 평가되며, 반환 값은 정수 형태이며, 바이트 단위의 크기를 나타낸다
    for (int i = 0; i < 10; i++) {
        printf("print : %d ", myArray[i]); // 0 0 0 0 0 0 0 0 0 0 출력
    }
    return 0;
}